{
  "version": 3,
  "sources": ["../../src/EventSource.ts", "../../src/client.ts"],
  "sourcesContent": ["export type Listener<T> = (event: T) => void;\r\nexport type UnsubscribeListener = () => void;\r\n\r\n//so i believe this is more for single purpose events, rather than general purpose events,\r\n//this is a single purpose event source, use for articular events\r\nexport class SingleEventSource<T> {\r\n  protected _listeners;\r\n\r\n  constructor() {\r\n    this._listeners = new Set<Listener<T>>();\r\n  }\r\n\r\n  subscribe = (listener: Listener<T>): UnsubscribeListener => {\r\n    this._listeners.add(listener);\r\n\r\n    return () => this._listeners.delete(listener);\r\n  };\r\n\r\n  notify = (event: T) => {\r\n    this._listeners.forEach((listener) => listener(event));\r\n  };\r\n}\r\n", "import { SingleEventSource } from \"./EventSource\";\r\n\r\nimport PartySocket from \"partysocket\";\r\n\r\nconst authTimeout = 10000;\r\nconst socketConnectTimeout = 10000;\r\nconst heartbeatInterval = 3000;\r\nconst connectionBackoff = [250, 500, 1000, 5000];\r\nconst authBackoff = [250, 500, 1000, 5000];\r\nconst maxConnTries = 7;\r\nconst maxAuthTries = 7;\r\n\r\nconst awaitPromise = <T = unknown>(\r\n  func: Promise<T>,\r\n  timeout: number\r\n): Promise<T> => {\r\n  let clearTimer: NodeJS.Timeout;\r\n  return new Promise(async (resolve, reject) => {\r\n    try {\r\n      clearTimer = setTimeout(\r\n        () => reject({ code: 99, msg: \"Auth timeout\" }),\r\n        timeout\r\n      );\r\n\r\n      const data = await func;\r\n      clearTimeout(clearTimer);\r\n      resolve(data);\r\n    } catch (error) {\r\n      clearTimeout(clearTimer);\r\n      reject(error);\r\n    }\r\n  });\r\n};\r\n\r\nfunction generateUUID(): string {\r\n  // Public Domain/MIT\r\n  if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\r\n    return crypto.randomUUID();\r\n  }\r\n  let d = new Date().getTime(); //Timestamp\r\n  let d2 =\r\n    (typeof performance !== \"undefined\" &&\r\n      performance.now &&\r\n      performance.now() * 1000) ||\r\n    0; //Time in microseconds since page-load or 0 if unsupported\r\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\r\n    let r = Math.random() * 16; //random number between 0 and 16\r\n    if (d > 0) {\r\n      //Use timestamp until depleted\r\n      r = (d + r) % 16 | 0;\r\n      d = Math.floor(d / 16);\r\n    } else {\r\n      //Use microseconds since page-load if supported\r\n      r = (d2 + r) % 16 | 0;\r\n      d2 = Math.floor(d2 / 16);\r\n    }\r\n    return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\r\n  });\r\n}\r\n\r\n//* OK what features we want\r\n//* auto reconnecting\r\n//* ping/pong timeouts\r\n//* status & messages\r\n//* manual reconnect\r\n//* manual close\r\n\r\n//* handling error events & backoffs\r\n\r\n//* [todo] Adding a protocol for diconnecting, and custom errors\r\n//* [todo] adding proper protcol for everything including auth\r\n//* [todo] move the socketListeners to top level and removing them\r\n//* [todo] adding proper cleanups\r\n//* [todo] adding statuses & pausing/resuming eventsources\r\n//* [todo] same as above make sure eventSource LISTENERS DON'T GET MESSAGE before open resolved\r\n//* [todo] adding failed states\r\n//* [todo] also add/remove listeners for navigator online/offline &  window focus\r\n//* [todo] also add/remove internal signals for close and error (check what the error  code is all about in websocket error & see if it's a possibility)\r\n//* [todo] plan on adding this back to partyworks :)\r\n\r\n//* [todo] adding teardown properly, see liveblocks when the y remove what message\r\n//* [TODO] MAKE PING A SEPARATE FUNCITON THAT TAKES BACK TO Conneciton, and onConnection should be a timeout not interval.this will allow for easily moving between when we want to ping on our end\r\n//* [todo] add a proper reset on diconnection & proper connections & counter states\r\n//* [todo] goes with the first one, adding proper function handlers for events\r\n//* [todo] add event listerners and remove them, for Window focus, navigator offline/online\r\n//* [todo] check to see if pausing messages is even necessary, or maybe adding 2 separate quques, still pausing would be required or maybe configurable evem\r\n//* [todo] add connection status & failed state as well\r\n//*\r\n\r\n//custom error class, that users can use to indicate stop retry, from auth & connectionResolver\r\nclass StopRetry extends Error {\r\n  constructor(msg: string) {\r\n    super(msg);\r\n  }\r\n}\r\n\r\ninterface ConnOptions {\r\n  waitForRoom: boolean;\r\n  host: string;\r\n  room: string;\r\n  userId?: string;\r\n  party?: string;\r\n  auth?: () => any | Promise<any>;\r\n  connectionResolver?: (\r\n    message: MessageEvent<any>,\r\n    resolver: () => void\r\n  ) => void;\r\n}\r\n\r\nexport class Conn {\r\n  status: \"stared\" | \"not_started\" = \"not_started\";\r\n  stateBlock:\r\n    | \"initial\"\r\n    | \"auth\"\r\n    | \"authError\"\r\n    | \"connection\"\r\n    | \"connectionError\"\r\n    | \"connected\"\r\n    | \"failed\" = \"initial\";\r\n  socket: WebSocket | null = null;\r\n  connRetry: number = 0;\r\n  authRetry: number = 0;\r\n  eventHub: { messages: SingleEventSource<MessageEvent<any>> };\r\n  counter = 0;\r\n\r\n  constructor(private options: ConnOptions) {\r\n    this.eventHub = {\r\n      messages: new SingleEventSource<MessageEvent<any>>(),\r\n    };\r\n\r\n    if (!options.userId) {\r\n      options.userId = generateUUID();\r\n    }\r\n  }\r\n\r\n  onSocketError = (event: Event) => {\r\n    console.log(`[Socket internal error]`, event);\r\n  };\r\n\r\n  onSocketClose = (event: CloseEvent) => {\r\n    console.log(`[Socket internal close]`, event);\r\n\r\n    //case we got the counter\r\n    //we got close\r\n    //we just wait for pong timeout to retry, life good\r\n\r\n    //case we got the counter\r\n    //we got close\r\n    //we have to close\r\n    //we just wait for pong timeout to retry, life good\r\n    //timer is increased\r\n    //auth stops\r\n\r\n    //case we got the counter\r\n    //we got close\r\n    //we have to close\r\n    //timer is increased\r\n    //we just wait for pong timeout to retry, life good [stale]\r\n\r\n    //case we got the counter\r\n    //we got close\r\n    //we have to close\r\n    //timer is increased\r\n    //we just wait for pong timeout to retry, life good [stale]\r\n    //reconnect -> timer increaed\r\n    //auth\r\n\r\n    //our signal to stop retry\r\n    if (event.code === 4000) {\r\n      this.counter++;\r\n      this.stateBlock = \"failed\";\r\n    }\r\n  };\r\n\r\n  buildUrl({\r\n    host: rawHost,\r\n    room,\r\n    userId,\r\n    protocol,\r\n    data,\r\n    party,\r\n  }: {\r\n    host: string;\r\n    room: string;\r\n    userId: string;\r\n    protocol?: string;\r\n    data: Record<string, string>;\r\n    party?: string;\r\n  }) {\r\n    // strip the protocol from the beginning of `host` if any\r\n    const host = rawHost.replace(/^(http|https|ws|wss):\\/\\//, \"\");\r\n\r\n    let url = `${\r\n      protocol ||\r\n      (host.startsWith(\"localhost:\") || host.startsWith(\"127.0.0.1:\")\r\n        ? \"ws\"\r\n        : \"wss\")\r\n    }://${host}/${party ? `parties/${party}` : \"party\"}/${room}`;\r\n    if (data) {\r\n      url += `?${new URLSearchParams({ ...data, userId }).toString()}`;\r\n    } else {\r\n      url += `?_pk=${userId}`;\r\n    }\r\n\r\n    console.log(`[Connection Url] ${url}`);\r\n\r\n    return url;\r\n  }\r\n\r\n  //block\r\n  async authentication() {\r\n    this.stateBlock = \"auth\";\r\n    const localCounter = this.counter;\r\n    console.log(`[Authenticating...]`);\r\n    if (typeof this.options.auth === \"function\") {\r\n      try {\r\n        const params = await awaitPromise(this.options.auth(), authTimeout);\r\n\r\n        if (this.counter !== localCounter) {\r\n          console.log(`[auth ok] but timers don't match, marked as stale`);\r\n          return;\r\n        }\r\n        console.log(`[auth ok] moving to -> connection block`);\r\n\r\n        this.connection(localCounter, params);\r\n      } catch (error) {\r\n        if (this.counter !== localCounter) {\r\n          console.log(`[auth failed] but timers don't match, marked as stale`);\r\n          return;\r\n        }\r\n        console.log(`[auth failed]  moving to -> error block`);\r\n        this.authError(localCounter, error);\r\n      }\r\n    }\r\n  }\r\n\r\n  //cell\r\n  async authError(counter: number, error: any) {\r\n    this.stateBlock = \"authError\";\r\n\r\n    if (error instanceof StopRetry) {\r\n      console.log(`[Auth Fail] Server said stop retry`);\r\n      return;\r\n    }\r\n\r\n    //here we can check the backoffs and add delays and stuff to it\r\n    //this is the function\r\n    if (this.authRetry >= maxAuthTries) {\r\n      console.log(`[Max Auth Tries] moving to -> Authentication Failed`);\r\n      return;\r\n    }\r\n\r\n    setTimeout(() => {\r\n      if (counter !== this.counter) {\r\n        console.log(`[stale] [Switch -> Auth Block]`);\r\n        return;\r\n      }\r\n\r\n      console.log(`[Switch -> Auth Block]`);\r\n\r\n      this.authentication();\r\n    }, authBackoff[this.authRetry] || 5000);\r\n\r\n    console.log(`[Schedule Reauth ${authBackoff[this.authRetry] || 5000}ms]`);\r\n    this.authRetry++;\r\n  }\r\n\r\n  //block\r\n  async connection(counter: number, params: any) {\r\n    this.stateBlock = \"connection\";\r\n    this.authRetry = 0;\r\n\r\n    try {\r\n      let conn = await this._connectSocket(\r\n        this.buildUrl({\r\n          host: params?.host || this.options.host,\r\n          room: params?.room || this.options.room,\r\n          userId: this.options.userId!,\r\n          party: this.options.party,\r\n          data: params?.data,\r\n        })\r\n      );\r\n\r\n      if (counter !== this.counter) {\r\n        console.log(`[stale] [Connection ok]`);\r\n\r\n        conn.close();\r\n        //@ts-ignore\r\n        conn = null; //apparently removes all event listeners,\r\n\r\n        //todo cleanup the socket\r\n        return;\r\n      }\r\n\r\n      this.socket = conn;\r\n\r\n      console.log(`[Connection ok] moving to -> connected block`);\r\n      this.connected(counter, conn);\r\n    } catch (error) {\r\n      if (counter !== this.counter) {\r\n        console.log(`[stale] [Connection fail]`);\r\n\r\n        return;\r\n      }\r\n\r\n      console.log(`[Connection fail] moving to -> connection error block`);\r\n      this.connectionError(counter, error);\r\n    }\r\n  }\r\n\r\n  //helper\r\n  async _connectSocket(url: string) {\r\n    if (\r\n      this.options.waitForRoom &&\r\n      typeof this.options.connectionResolver !== \"function\"\r\n    )\r\n      throw new Error(\r\n        \"Bad Config, no connectionResolver provided when waitForRoom was to true\"\r\n      );\r\n    let con: WebSocket | null = null;\r\n    let messageListenerRef: (v: any) => void;\r\n    let connectionResolverRef: (v: any) => void;\r\n    let cleanupRejectRef: (v: any) => void;\r\n\r\n    const connectedSock = new Promise<WebSocket>((resolve, reject) => {\r\n      const conn = new WebSocket(url);\r\n\r\n      con = conn;\r\n\r\n      const messageListener = (e: MessageEvent<any>) => {\r\n        this.eventHub.messages.notify(e);\r\n      };\r\n      messageListenerRef = messageListener;\r\n\r\n      const connectionResolver = (e: MessageEvent<any>) => {\r\n        if (typeof this.options.connectionResolver === \"function\") {\r\n          this.options.connectionResolver(e, () => {\r\n            conn.addEventListener(\"close\", cleanupReject);\r\n            conn.removeEventListener(\"error\", cleanupReject);\r\n            conn.removeEventListener(\"message\", connectionResolver);\r\n            resolve(conn);\r\n          });\r\n        }\r\n      };\r\n      connectionResolverRef = connectionResolver;\r\n\r\n      const cleanupReject = (e: any) => {\r\n        // console.log(`[]er `, e); // not useful, can't get any code out of it\r\n        conn.removeEventListener(\"message\", messageListener);\r\n        reject(conn);\r\n      };\r\n\r\n      cleanupRejectRef = cleanupReject;\r\n\r\n      conn.addEventListener(\"open\", () => {\r\n        if (!this.options.waitForRoom) {\r\n          conn.removeEventListener(\"close\", cleanupReject);\r\n          conn.removeEventListener(\"error\", cleanupReject);\r\n          resolve(conn);\r\n        }\r\n      });\r\n      conn.addEventListener(\"close\", cleanupReject);\r\n      conn.addEventListener(\"error\", cleanupReject);\r\n\r\n      if (\r\n        this.options.waitForRoom &&\r\n        typeof this.options.connectionResolver === \"function\"\r\n      )\r\n        conn.addEventListener(\"message\", connectionResolver);\r\n\r\n      conn.addEventListener(\"message\", messageListener);\r\n\r\n      conn.addEventListener(\"close\", this.onSocketClose);\r\n      conn.addEventListener(\"error\", this.onSocketError);\r\n    });\r\n\r\n    try {\r\n      const con = await awaitPromise<WebSocket>(\r\n        connectedSock,\r\n        socketConnectTimeout\r\n      );\r\n      return con;\r\n    } catch (error) {\r\n      //The case where the conn is timeout, but the conn succeeds, this will leave a rouge conn\r\n      //given a normal timeout of say 10sec it's higly unlike to happen\r\n      if (con) {\r\n        (con as WebSocket)?.removeEventListener(\"close\", cleanupRejectRef!);\r\n\r\n        (con as WebSocket)?.removeEventListener(\"error\", cleanupRejectRef!);\r\n\r\n        (con as WebSocket)?.removeEventListener(\r\n          \"message\",\r\n          connectionResolverRef!\r\n        );\r\n        (con as WebSocket)?.removeEventListener(\"message\", messageListenerRef!);\r\n\r\n        (con as WebSocket)?.close();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  //cell\r\n  connectionError(counter: number, error: any) {\r\n    this.stateBlock = \"connectionError\";\r\n\r\n    if (error instanceof StopRetry) {\r\n      console.log(`[Stop Retry] Connection Failed`);\r\n      return;\r\n    }\r\n\r\n    if (this.connRetry >= maxConnTries) {\r\n      console.log(`[Max Conn Tries] moving to -> Connection Failed`);\r\n      return;\r\n    }\r\n\r\n    setTimeout(() => {\r\n      if (counter !== this.counter) {\r\n        console.log(`[stale] [Switch -> Auth Block]`);\r\n        return;\r\n      }\r\n\r\n      console.log(`[Switch -> Auth Block]`);\r\n      this.authentication();\r\n    }, connectionBackoff[this.connRetry] || 5000);\r\n\r\n    console.log(\r\n      `[Schedule Reconnect ${connectionBackoff[this.connRetry] || 5000}ms]`\r\n    );\r\n    this.connRetry++;\r\n  }\r\n\r\n  //cell\r\n  async connected(counter: number, conn: WebSocket) {\r\n    this.stateBlock = \"connected\";\r\n    this.connRetry = 0;\r\n    const interval = setInterval(() => {\r\n      //* ok here what's the scenario ?\r\n      //* let's say a reconnect happened\r\n      //* the normal assumption would be that the socket is closed\r\n      //* so we just check the counter every interval/timeout\r\n      //* if the counters off we just clear the intervals & timeouts\r\n      //* and assume that the conn will get taken care of\r\n\r\n      if (counter !== this.counter) {\r\n        console.log(`[stale] [CONNECTED PING]`);\r\n        clearInterval(interval);\r\n\r\n        return;\r\n      }\r\n\r\n      console.log(`[CONNECTED PING]`);\r\n      conn.send(\"PING\");\r\n\r\n      const timeout = setTimeout(() => {\r\n        if (counter !== this.counter) {\r\n          console.log(`[stale] [PONG TIMEOUT]`);\r\n          clearInterval(interval);\r\n          return;\r\n        }\r\n        console.log(`[PONG TIMEOUT] moving to -> authentication block`);\r\n        //cleanup socket\r\n        clearInterval(interval);\r\n        this.removeConnection(conn);\r\n        this.authentication();\r\n      }, 2000);\r\n\r\n      const unsub = this.eventHub.messages.subscribe((e) => {\r\n        if (e.data === \"PONG\") {\r\n          console.log(`[CONNECTED PONG]`);\r\n          clearTimeout(timeout);\r\n          unsub();\r\n        }\r\n      });\r\n    }, heartbeatInterval);\r\n  }\r\n\r\n  //cell\r\n  async ping(counter: number, conn: WebSocket) {}\r\n\r\n  //helper\r\n  removeConnection(socket: WebSocket) {\r\n    if (socket) {\r\n      socket.removeEventListener(\"close\", this.onSocketClose);\r\n      socket.removeEventListener(\"error\", this.onSocketError);\r\n      socket.close();\r\n    }\r\n  }\r\n\r\n  //this closes the socket, always called before reauth\r\n  closeSocket() {\r\n    if (this.socket) {\r\n      console.log(`[Con closed]`);\r\n      this.socket.removeEventListener(\"close\", this.onSocketClose);\r\n      this.socket.removeEventListener(\"error\", this.onSocketError);\r\n      this.socket.close();\r\n      this.socket = null;\r\n    }\r\n  }\r\n\r\n  start() {\r\n    if (this.status === \"stared\") {\r\n      console.warn(`Conn has already started`);\r\n      return;\r\n    }\r\n\r\n    this.status = \"stared\";\r\n    this.authentication();\r\n  }\r\n\r\n  //only stop if you want to stop the conn\r\n  //reconn won't happen after this\r\n  stop() {\r\n    if (this.status === \"stared\") {\r\n      this.status = \"not_started\";\r\n\r\n      this.counter++;\r\n      this.closeSocket();\r\n      //whatever pos it's in, we can easily just increase the counter,\r\n      //and the counter guards will take care of stopping themselves\r\n      //we just need to close if any existing con is there\r\n\r\n      //ok somehow make sure to cleanup this\r\n      //close the currently ongoing stuff\r\n      //also close the current conneciton if any\r\n    }\r\n  }\r\n\r\n  //so thinking of a case where we are manually guarding\r\n  //let's say connection only updates properly, but during that period there is a reconnect\r\n  //and now we're guarding on the stateBlock, it's all fine\r\n  //but assuming that the block comes to the same status when the first socket is accepted\r\n  //aauu shit we have 2 connections\r\n  //so we need to have exit functions that make it stale in a manner\r\n  //but how do exit functions know what to cleanup ?\r\n  //the cleanup then should be how?\r\n  //this is the only case that's a race condition, and can happen\r\n  //we need to prepare for it, the only way to make it stale somehow\r\n  //but maybe for now let's ignore that particular case\r\n  //the problem is that it can happen to all listeners\r\n\r\n  //* ok got a solution for the above, i.e. having counters, everytime an event like that happens the counter is updated,\r\n  //* we only look at the counter locally if it still matches then we win else we lose and do a cleanup\r\n\r\n  //* rethink the scenario for simple explaination\r\n  //* machine starts [counter 0]\r\n  //* authenticating [counter 0]\r\n  //* reconnect happens [counter 1]\r\n  //* goes back to authenticating [counter 1]\r\n  //* auth resolves [counter 0] counters don;t match oops stale event, do a cleanup/exit/ignore\r\n\r\n  //* rethink the scenario 2\r\n  //* machine starts [counter 0]\r\n  //* authenticating [counter 0]\r\n  //* authError [counter 0], a timeout is set to move to auth\r\n  //* reconnect happens [counter 1]\r\n  //* goes back to authenticating [counter 1]\r\n  //* timeout executes [counter 0] oops counters don't match, do a cleanup\r\n\r\n  //* ok the below scenario obv tells us to use the counter during auth only\r\n  //* and pass the counter between calls, not very cool, but can be refactored\r\n\r\n  //* shit scenario\r\n  //* machine starts [counter 0]\r\n  //* authenticating [counter 0]\r\n  //* reconnect happens [counter 1]\r\n  //* authError [counter 1], a timeout is set to move to auth\r\n  //* goes back to authenticating [counter 1]\r\n  //* connection [counter 1] //conn from reconnect\r\n  //* connection [counter 1] //conn from authError timeout\r\n\r\n  //* rethink the scenario 3\r\n  //* machine starts [counter 0]\r\n  //* authenticating [counter 0]\r\n  //* authError [counter 0], a timeout is set to move to auth\r\n  //* timeout executes [counter 0] back to authentication\r\n  //* reconnect happens but same state, so it's ignored || //* reconnect happens but same state, so redo with counter\r\n\r\n  //* rethink the scenario 4\r\n  //* machine starts [counter 0]\r\n  //* authenticating [counter 0]\r\n  //* connection [counter 0]\r\n  //* reconnect happens [counter 1]\r\n  //* connection success [counter 0] but oops counter don't match, so fail & cleanup\r\n\r\n  //* So the cases where we're in the correct place, ex\r\n  //* connRetry moves back to auth\r\n  //* reconnect happens\r\n  //* since it's the same place, we leave it be? or do we redo it again? both are possible with the current setup it'll just work\r\n\r\n  //* now a case where we're happily connected\r\n  //* reconnect happens\r\n  //* umm, hmm... we exited the connection, so based on our state we nead to run exitConnection cleanup funciton ithink\r\n\r\n  //so we basically need these as gatekeepers as well for state transitiong, and the internal machine only should be responsible for the transition\r\n  //and these will talk to the machine?\r\n  //let's say conn is timedout & rejected, but later the conn actually get connected it may cause a race condition\r\n\r\n  async idle() {}\r\n  async enterAuth() {}\r\n  //authentication\r\n  //authError\r\n  async exitAuth() {}\r\n  async enterConnection() {}\r\n  //connection\r\n  //connectionError\r\n  async exitConnection() {}\r\n  enterConnected() {}\r\n  //connected\r\n  //connectedError\r\n  async exitConnected() {\r\n    console.log(`[Exit Conn]`);\r\n    this.socket?.close();\r\n  }\r\n\r\n  //userland events should increase the counter\r\n  async reconnect() {\r\n    if (this.status !== \"stared\") {\r\n      console.warn(`Cannot reconnect machine is not started`);\r\n      return;\r\n    }\r\n\r\n    if (this.stateBlock === \"connected\") {\r\n      this.exitConnected();\r\n    }\r\n    this.counter++;\r\n    this.authentication();\r\n  }\r\n\r\n  async close() {\r\n    if (this.status !== \"stared\") {\r\n      console.warn(`Cannot reconnect machine is not started`);\r\n      return;\r\n    }\r\n\r\n    if (this.stateBlock === \"connected\") {\r\n      this.exitConnected();\r\n    }\r\n\r\n    this.counter++;\r\n  }\r\n}\r\n\r\nconst happyAuth = () => {\r\n  return {\r\n    url: `ws://localhost:1999/party/b?_pk=78${Math.random().toString()}9ae98c${Math.random().toString()}-2f8b-4a5d-9c11${(\r\n      Math.random() * Math.random()\r\n    ).toString()}-74df958f5655`,\r\n  };\r\n};\r\n\r\nconst happyAuthPromise = (timeout: number = 2000) => {\r\n  return new Promise((res, rej) => {\r\n    setTimeout(() => {\r\n      res({\r\n        url: `ws://localhost:1999/party/b?_pk=78${Math.random().toString()}9ae98c${Math.random().toString()}-2f8b-4a5d-9c11${(\r\n          Math.random() * Math.random()\r\n        ).toString()}-74df958f5655`,\r\n      });\r\n    }, timeout);\r\n  });\r\n};\r\n\r\nconst badUrlAuth = () => {\r\n  return {\r\n    url: \"ws://localhost:1999\",\r\n  };\r\n};\r\n\r\nconst badAuth = () => {\r\n  return new Promise((res, rej) => {\r\n    rej({ code: 1 });\r\n  });\r\n};\r\n\r\nconst timeoutAuth = () => {\r\n  return new Promise((res, rej) => {\r\n    setTimeout(() => {\r\n      res({});\r\n    }, authTimeout + 100);\r\n  });\r\n};\r\n\r\nconst con = new Conn({\r\n  host: \"localhost:1999\",\r\n  room: \"bb\",\r\n  auth: happyAuthPromise,\r\n  waitForRoom: false,\r\n\r\n  //use to wait for a prticular message, waitForRoom should be true\r\n  connectionResolver: function connectionResolver(\r\n    e: MessageEvent<any>,\r\n    resolver\r\n  ) {\r\n    if (typeof e.data === \"string\") {\r\n      try {\r\n        const data = JSON.parse(e.data);\r\n\r\n        if (data && data._pwf === \"-1\" && data.event === 4) {\r\n          console.log(data);\r\n          resolver();\r\n        }\r\n      } catch (error) {}\r\n    }\r\n  },\r\n});\r\n\r\ncon.start();\r\n// const cons = new Party({ room: \"b\", host: \"ws://localhost:1999\" });\r\n// con.reconnect();\r\n// con.eventHub.messages.subscribe((msg) => {\r\n//   console.log(msg);\r\n// });\r\n\r\n// setTimeout(() => {\r\n//   con.reconnect();\r\n// }, 2000);\r\n\r\nconst buttonElement: HTMLButtonElement = document.createElement(\"button\");\r\nbuttonElement.textContent = \"Reconnect\"; // Set the button text\r\n\r\n// Add the button to the document body or any other HTML element\r\ndocument.body.appendChild(buttonElement);\r\n\r\n// Define a click event listener function\r\nfunction buttonClickHandler(event: MouseEvent) {\r\n  con.reconnect();\r\n}\r\n\r\n// Attach the click event listener to the button\r\nbuttonElement.addEventListener(\"click\", buttonClickHandler);\r\n\r\nconst cc: HTMLButtonElement = document.createElement(\"button\");\r\ncc.textContent = \"Stop\"; // Set the button text\r\n\r\n// Add the button to the document body or any other HTML element\r\ndocument.body.appendChild(cc);\r\n\r\n// Define a click event listener function\r\nfunction ccWa(event: MouseEvent) {\r\n  con.stop();\r\n}\r\n\r\n// Attach the click event listener to the button\r\ncc.addEventListener(\"click\", ccWa);\r\n\r\nconst dd: HTMLButtonElement = document.createElement(\"button\");\r\ndd.textContent = \"Close\"; // Set the button text\r\n\r\n// Add the button to the document body or any other HTML element\r\ndocument.body.appendChild(dd);\r\n\r\n// Define a click event listener function\r\nfunction ddWa(event: MouseEvent) {\r\n  con.close();\r\n}\r\n\r\n// Attach the click event listener to the button\r\ndd.addEventListener(\"click\", ddWa);\r\n"],
  "mappings": "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",
  "names": ["con", "connectionResolver"]
}
